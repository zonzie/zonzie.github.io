---
title: 工厂方法模式
date: 2018-06-03 18:31:12
tags: 
	- design pattern
categories: design pattern
description: 设计模式--工厂方法模式
---
> 工厂方法模式的定义: **Define an interface for creating an object, but let subclasses decide which class to instantiate.Factory Method lets a class defer instantiation to subclasses**.(定义一个用于创建对象的接口,让子类决定实例化哪一个类.工厂方法使一个类的实例化延迟到子类)

#### 一个简单的例子
```java
// 抽象产品类
public abstract class Product {
	// 产品类的公共方法
	public void methodA() {
		// 业务逻辑处理
	}
	// 抽象方法
	public abstract void methodB();
}
// 具体产品类
public void productA extends Product {
	public void methodB() {
		// 业务逻辑处理
	}
}
public void productB extends Product {
	public void methodB() {
		// 业务逻辑处理
	}
}
// 抽象工厂类
public abstract class Creator() {
	// 创建一个产品对象,输入的参数类型自行设置(通常为String,Enumm,Class等,也可以为空)
	public abstract <T extends Product> T createProduct(Class<T> c);
}
// 具体工厂类
public class ConcreteCreator extends Creator {
	public <T extends Product> T createProduct(Class<T> c) {
		Product product = null;
		try {
			product = (Product) Class.forName(c.getName()).newInstance();
		} catch(Exception e) {
			e.printStackTrace();
		}
		return (T)product;
	}
}
// 场景类
public class Client {
	public static void main(String...args) {
		Creator creator = new ConcreteCreator();
		Product productA = creator.createProduct(ProductA.class);
		// 处理业务逻辑
		// ...
	}
}
```
#### 工厂方法模式的优点
- 封装良好,结构清晰,只需要类名,不需要知道创建对象的具体过程
- 扩展性非常的优秀,增加新的类型,只需要修改具体的工厂类就可以了
- 屏蔽具体的对象,只需要关心接口,只要接口不发生变化,上层模块就不用发生变化
- 工厂方法模式是典型的解耦框架,符合迪米特法则,也符合依赖倒置原则,也符合里氏替换原则,使用子类替换父类

#### 工厂方法模式的使用场景
- 需要灵活,可扩展的框架时,可以考虑使用工厂方法模式
- 使用在异构项目中,通过webService与非java项目交互
- 可以使用在测试驱动的开发框架下

#### 工厂方法模式的扩展
- 缩小为简单工厂模式,即去掉工厂的抽象类,直接使用工厂类
- 升级为多个工厂类
```java
// 多工厂模式的抽象工厂类
public abstract class AbstractFactory {
	public abstract Product createProduct();
}
// 产品A的工厂
public class ProductAFactory extends AbstractFactory {
	public Product createProduct() {
		return new ProductA();
	}
}
// 产品B的工厂
public class ProductBFactory extends AbstractFactory {
	public Product createProduct() {
		return new ProductB();
	}
}
// 场景类
public class client {
	public static void main(String... args) {
		Product ProductA = new ProductAFactory().createProduct();
		// 产品A的相关操作
		// ...
		Product productB = new ProductBFactory().createProduct();
		// 产品B的相关操作
		// ...
	}	
}
```
- 替代单例模式,通过反射生成实例
```java
// 单例类
public class Singleton {
	private Singleton() {}
	public void doSomthing() {
		// ......
	}
}
public class SingletonFactory {
	private static Singleton singleton;
	static {
		try {
			class clazz = Class.forName(Singleton.class.getName());
			// 获得无参数的构造方法
			Constructor constructor = clazz.getDeclaredConstructor();
			constructor.setAccessible(true);
			// 产生一个实例对象
			singleton = (Singleton) constructor.newInstance();
		} catch(Exception e) {
			// 异常处理
		}
	}
	
	public static Singleton getSingleton() {
		return singleton;
	}
}
```
- 延迟加载工厂类
```java
public class ProductFactory {
	private static final Map<String, Product> prMap = new hashMap();
	public static synchronized Product createProduct(String type) {
		Product product = null;
		// 如果map中存在这个对象
		if(prMap.containsKey(type)) {
			product = prMap.get(type);
		} else {
			if(type.equals("ProductA")) {
				product = new ProductA();
			}
			if(type.equals("ProductB")) {
				product = new ProductB();
			}
			// 将对象放入map容器中
			prMap.put(type, product);
		}
		return product;
	}
}
```


