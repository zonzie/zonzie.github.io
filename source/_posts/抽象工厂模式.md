---
title: 抽象工厂模式
date: 2018-06-06 16:51:25
tags: 
	- design pattern
categories: design pattern
description: 设计模式--抽象工厂模式
---
> 抽象工厂模式的定义: **Provide an interface for creating families of related or dependent objects without specifying their concrete classes.**(为创建一组相关的或者相互依赖的对象提供一个接口,而且无需指定他们的具体类)

#### 一个例子
```
// 抽象的产品
public abstract class AbstractProductA {
	public void shareMethod() {
		// 所有的产品共有的方法
	}
	// 不同实现的方法
	public abstract void doSomething();
}
// 具体的产品A1
public class ProductA1 extends AbstractProductA {
	// 具体实现
	public void doSomething() {
		System.out.println("this is productA1...");
	}
}
// 具体的产品A2
public class ProductA2 extends AbstractProductA {
	// 具体的实现
	public void doSomthing() {
		System.out.println("this is productA2...");
	}
}
// 抽象工厂类
public abstract class AbstractCreator {
	// 创建A类产品工厂
	public abstract AbstractProductA createProductA();
	// 创建B类产品工厂
	public abstract AbstractProductB createProductB();
}
// 产品等级1的实现类
public class Creator1 extends AbstractCreator {
	public AbstractProductA createProductA() {
		// 只生产产品等级为1的A产品
		return new ProductA1();
	}
	public AbstractProductB createProductB() {
		// 只生产产品等级为1的B产品		
		return new ProductB1();
	}
}
// 产品等级为2的实现类
public class Creator2 extends AbstractCreator {
	// 只生产产品等级为2的A产品
	public AbstractProductA createProductA() {
		return new ProductA2();
	}
	// 只生产产品等级为2的B产品
	public AbstractProductB createProductB() {
		return new ProductB2();
	}
}
// 场景类
public class Client {
	public static void main(String... args) {
		// 定义工厂
		AbstractCreator creator1 = new Creator1();
		AbstractCreator creator2 = new Creator2();
		// 产生A1对象
		AbstractProductA a1 = creator1.createProductA();
		// 对象b1
		AbstractProductB b1 = creator1.createProductB();
		// 对象A2
		AbstractProductA a2 = creator2.createProductA();
		// 对象B2
		AbstractProductB b2 = creator2,createProductB();
		// 对相关对象的相关操作
		// ...
	}
}
```
#### 抽象工厂模式的优点
- 封装性,只需要关心接口而不是实现类
- 产品族内的约束为非公开的状态

#### 抽象工厂模式的缺点
- 扩展工厂类非常困难,需要改动大量的代码

#### 抽象工厂使用场景
- 一组对象都有相同的约束,就可以使用抽象工厂模式,例如一个应用需要在不同的平台运行,就可以通过抽象工厂模式屏蔽掉不同平台的影响,不同平台上的软件功能,应用逻辑,UI都应该是非常类似的,唯一不同的是,调用不同的工厂方法,由不同的产品类去处理与操作系统的交互.