---
title: 单例模式
date: 2018-06-03 15:30:14
tags: 设计模式
categories: design pattern
description: 设计模式--单例模式
---
#### 单例模式的定义
> 单例模式(singleton pattern) 是一个比较简单的模式,定义如下:
**Ensure a class has only one instance, and provide a global point of access to it.**(确保某一个类只有一个实例,而且自行实例化并向这个系统提供这个实例)

#### 单例模式的通用代码:

```java
public class Sinigleton {
	private static final Singleton singleton = new Singleton();
	// 限制产生多个对象
	private Singleton() {
	}
	// 通过该方法获得实例对象
	public static Singleton getSingleton() {
		return singelton;
	}
	// 类中其他方法
	public static void doSomething() {
	}
}
```
#### 单例模式的优点
1. 减少内存开支,特别是一个对象需要频繁创建,销毁时
2. 当一个对象的产生需要比较多的资源时,比如读取配置文件,产生其他依赖度对象时
3. 避免对资源的多重占用,例如写文件的动作,只有一个实例存在内存中,避免对同一个资源文件的同时写操作
4. 可以在系统中设置全局的访问点,优化共享资源的访问

#### 单例模式的缺点
1. 单例模式没有接口,扩展困难
2. 对测试不利,并行开发环境中,单例未开发完成,无法进行测试
3. 单例模式和单一职责原则有冲突

#### 单例模式的使用场景
1. 要求生成唯一序列号的环境
2. 在整个项目中需要一个共享的数据访问点或者共享数据
3. 创建一个对象消耗资源过多时,如访问IO和数据库资源等
4. 需要大量的静态常量或者静态方法的环境,可以采用单例模式,也可以是枚举类(也是一种单例)或者定义为static的方式

#### 单例模式的几种形式
- **懒汉式单例(线程不安全)**,在第一次调用时实例化自己
```java
public class Singleton {
	private Singleton(){}
	private static Singleton single = null;
	// 静态工厂方法
	public static Singleton getInstance() {
		if(single == null) {
			single = new Singleton();
		}
		return single;
	}
}
```
- **懒汉式(线程安全)**
```
// 1. 加锁
public static synchronized Singelton getInstance() {
	if(single == null) {
		single = new Singleton();
	}
	return single;
}
// 2. 双重检查
public static Singleton getInstance() {
	if(singleton == null) {
		synchronized (Singleton.class) {
			if(singleton == null) {
				singleton = new Singleton();
			}
		}
	}
	return singleton;
}
// 3. 静态内部类
public class Singleton {
	private	static class LazyHolder {
		private static final Singleton INSTANCE = new Singelton();
	}
	private Singleton (){}
	public static final Singleton getInstance() {
		return LazyHolder.INSTANCE;	
	}
}
```
- **饿汉式**
```
//在类初始化时,已经实例化
public static Singleton {
	private Singleton() {}
	private static final Singleton single = new Singleton();
	// 静态工厂方法
	public static Singleton getInstance() {
		return single;
	}
}
```
- **产生固定个数实例的单例模式**
```
public class Singleton {
	// 最多产生几个实例
	private static int maxNumber = 2;
	// 存储每个实例的名字
	private static List<String> nameList = new ArrayList<String>();
	// 定义一个列表,容纳所有的实例
	private static List<Singleton> instancelist = new ArrayList<Singelton>();
	// 当前实例的序列号
	private static int countNumOfInstance = 0;
	// 产生所有的实例
	static {
		for(int i = 0; i < maxNumber; i++) {
			instanceList.add(new Emperor("实例"+(i+1)));
		}
	}
	// 私有化构造
	private Singelton(){}
	// 传入名称,建立对象
	private Singleton (String name) {
		nameList.add(name);
	}
	// 随机获得一个实例 
	public static Singleton getInstance() {
		Random random = new Random();	
		countNumOfInstance = random.nextInt(maxNumOfSingelton);
		return instanceList.get(countNumOfInstance);
	}
	// 获取当前实例的名称
	public static void currentInstance() {
		System.out.println(nameList.get(countNumOfSingleton));
	}
	
}
```
- **登记式单例**
```
public class singleton {
	private static Map<String,Singleton> map = new HashMap<String,Singleton>();
	static {
		Singleton single = new Singelton();
		map.put(single.getClass().getName(), single);
	}
	// 私有的构造
	private Singelton(){}
	// 实例工厂
	public static Singleton getInstance(String name) {
		if(name == null) {
			name = Singelton.class.getName();
			System.out.println("name == null"+"---->name:"+name);
		}
		if(map.get(name) == null) {
			try{
				map.put(name, (Singleton)Class.forName(name).newInstance());
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
		return map.get(name);
	}
}
```
	
